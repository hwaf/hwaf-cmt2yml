package main

import (
	"fmt"
	"io"
	"os"
	"os/exec"
	"path"
	"path/filepath"
	"strings"

	"github.com/gonuts/yaml"
)

func render_yaml(req *ReqFile) error {
	var err error

	fname := filepath.Join(filepath.Dir(filepath.Dir(req.Filename)), "hscript")
	hscript, err := os.Create(fname)
	handle_err(err)
	defer hscript.Close()

	err = req.ToYaml(hscript)
	handle_err(err)

	hscript.Sync()
	err = hscript.Close()
	handle_err(err)

	if false {
		hscript, err = os.Open(fname)
		handle_err(err)
		hprint, err := os.Create(fname + ".ok")
		handle_err(err)

		pprint := exec.Command("python", "-c", "import yaml, sys; o = yaml.load(sys.stdin); yaml.dump(o, stream=sys.stdout)")
		pprint.Stdin = hscript
		pprint.Stdout = hprint
		err = pprint.Run()
	}

	return err
}

type hscript_t struct {
	Package   hpackage_t   `yaml:"package,flow"`
	Options   hoptions_t   `yaml:"options,omitempty"`
	Configure hconfigure_t `yaml:"configure,omitempty"`
	Build     hbuild_t     `yaml:"build,flow,omitempty"`
}

type hpackage_t struct {
	Name     string   `yaml:"name,flow"`
	Authors  []string `yaml:"authors,flow,omitempty"`
	Managers []string `yaml:"managers,flow,omitempty"`
	Version  string   `yaml:"version,flow,omitempty"`
	Deps     hdeps_t  `yaml:"dependencies,flow,omitempty"`
}

type hdeps_t struct {
	Public  []string `yaml:"public,flow,omitempty"`
	Private []string `yaml:"private,flow,omitempty"`
	Runtime []string `yaml:"runtime,flow,omitempty"`
}

type hoptions_t struct {
	Tools    []string `yaml:"tools,flow,omitempty"`
	HwafCall []string `yaml:"hwaf-call,flow,omitempty"`
}

type hconfigure_t struct {
	Tools    []string `yaml:"tools,flow,omitempty"`
	Env      henv_t   `yaml:"env,omitempty"`
	Tag      []string `yaml:"tag,flow,omitempty"`
	HwafCall []string `yaml:"hwaf-call,flow,omitempty"`
}

// type henv_t struct {
// 	Map map[string]interface{} `yaml:"map,flow"`
// }
type henv_t map[string]interface{} //FIXME: map[string][]interface{} instead ??

// type hbuild_t struct {
// 	Targets  htargets_t `yaml:"tgts,flow,omitempty"`
// 	HwafCall []string   `yaml:"hwaf-call,flow,omitempty"`
// }

type hbuild_t map[string]interface{}

type htargets_t []htarget_t

type htarget_t struct {
	Name     string   `yaml:"name,flow,omitempty"`
	Features string   `yaml:"features,flow"`
	Source   []string `yaml:"source,flow"`
	Use      []string `yaml:"use,flow,omitempty"`
	Defines  []string `yaml:"defines,flow,omitempty"`
}

func sanitize_srcs(sources []string) []string {
	for i, src := range sources {
		if strings.HasPrefix(src, "../") {
			sources[i] = src[len("../"):]
		}
	}
	return sources
}

func sanitize_env_string(v string) string {
	v = strings.Replace(v, "$(", "${", -1)
	v = strings.Replace(v, ")", "}", -1)
	if strings.HasPrefix(v, `"`) {
		v = v[1:]
	}
	if strings.HasSuffix(v, `"`) {
		v = v[0 : len(v)-1]
	}
	return v
}

func init_env_map_from(env henv_t, key string) map[string]interface{} {
	vv := map[string]interface{}{}
	old, haskey := env[key]
	if haskey {
		switch old.(type) {
		case string:
			vv["default"] = old
			panic("boo")
		case map[string]interface{}:
			old := env[key].(map[string]interface{})
			for k, _ := range old {
				vk := sanitize_env_string(k)
				vk = strings.Trim(vk, " ")
				vv[vk] = old[k]
			}
		default:
			panic(fmt.Sprintf("unknown type: %T", old))
		}
	}
	return vv
}

func (req *ReqFile) ToYaml(w io.Writer) error {
	var err error

	_, err = fmt.Fprintf(
		w,
		"## automatically generated by cmt2yml\n## do NOT edit\n\n",
	)
	handle_err(err)

	basedir := filepath.Dir(filepath.Dir(req.Filename))

	hscript := hscript_t{
		Package:   hpackage_t{Name: basedir},
		Configure: hconfigure_t{Env: make(map[string]interface{})},
		Build:     make(hbuild_t, 0),
	}

	//complibs := map[string]struct{}{}
	linklibs := map[string]*Library{}
	apps := map[string]*Application{}
	//dictlibs := map[string]struct{}{}

	for _, stmt := range req.Stmts {
		hpkg := &hscript.Package
		hbld := hscript.Build
		hcfg := &hscript.Configure

		if author, ok := stmt.(*Author); ok {
			hpkg.Authors = append(hpkg.Authors, author.Name)
		}

		if mgr, ok := stmt.(*Manager); ok {
			hpkg.Managers = append(hpkg.Managers, mgr.Name)
		}

		if version, ok := stmt.(*Version); ok {
			hpkg.Version = version.Value
		}

		if use, ok := stmt.(*UsePkg); ok {
			deps := &hpkg.Deps
			if use.IsPrivate {
				deps.Private = append(deps.Private, path.Join(use.Path, use.Package))
			} else {
				deps.Public = append(deps.Public, path.Join(use.Path, use.Package))
			}
		}

		if lib, ok := stmt.(*Library); ok {
			linklibs[lib.Name] = lib
			tgt := htarget_t{Name: lib.Name}
			sanitize_srcs(lib.Source)
			for _, src := range lib.Source {
				tgt.Source = append(tgt.Source, src)
			}
			if features, ok := g_profile.features["library"]; ok {
				tgt.Features = features
			}
			hbld[tgt.Name] = tgt
		}

		if app, ok := stmt.(*Application); ok {
			apps[app.Name] = app
			tgt := htarget_t{Name: app.Name}
			sanitize_srcs(app.Source)
			for _, src := range app.Source {
				tgt.Source = append(tgt.Source, src)
			}
			if features, ok := g_profile.features["application"]; ok {
				tgt.Features = features
			}
			hbld[tgt.Name] = tgt
		}

		if pat, ok := stmt.(*ApplyPattern); ok {
			if false {
				fmt.Printf(">>> apply-pattern=%q\n", pat.Name)
			}
		}

		if pat, ok := stmt.(*Pattern); ok {
			if false {
				fmt.Printf(">>> pattern=%q\n", pat.Name)
			}
		}

		if p, ok := stmt.(*Macro); ok {
			fmt.Printf("--- %q %v\n", p.Name, p.Value)
			vv := init_env_map_from(hcfg.Env, p.Name)
			for tag, v := range p.Value {
				v = sanitize_env_string(v)
				vv[tag] = v
			}
			if len(vv) > 0 {
				hcfg.Env[p.Name] = vv
			}
		}

		if p, ok := stmt.(*MacroAppend); ok {
			//fmt.Printf("--- %q %v\n", p.Name, p.Value)
			vv := init_env_map_from(hcfg.Env, p.Name)
			for tag, v := range p.Value {
				v = sanitize_env_string(v)
				v = strings.Trim(v, " ")
				if _, haskey := vv[tag]; haskey {
					old := vv[tag]
					//fmt.Printf("--> %q\n", old)
					switch old.(type) {
					case string:
						old := old.(string)
						if old == "" && v == "" {
							// no-op
						} else if old != "" && v == "" {
							vv[tag] = old
						} else if old == "" && v != "" {
							vv[tag] = v
						} else {
							vv[tag] = []string{old, v}
						}
					case []string:
						old := old.([]string)
						if v != "" {
							val := make([]string, len(old)+1)
							copy(val, old)
							val = append(val, v)
							vv[tag] = val
						}
					}

				} else {
					if v == "" {
						// no-op
					} else {
						vv[tag] = []string{fmt.Sprintf("${%s}", p.Name), v}
					}
				}
			}
			if len(vv) > 0 {
				hcfg.Env[p.Name] = vv
			}
		}

		if p, ok := stmt.(*PathAppend); ok {
			//fmt.Printf("--- %q %v\n", p.Name, p.Value)
			vv := init_env_map_from(hcfg.Env, p.Name)
			for tag, v := range p.Value {
				v = sanitize_env_string(v)
				if _, haskey := vv[tag]; haskey {
					old := vv[tag]
					//fmt.Printf("--> %q\n", old)
					if old == "" && v == "" {
						// no-op
					} else if old != "" && v == "" {
						vv[tag] = old
					} else if old == "" && v != "" {
						vv[tag] = v
					} else {
						vv[tag] = fmt.Sprintf("%s:%s", old, v)
					}

				} else {
					if v == "" {
						vv[tag] = fmt.Sprintf("${%s}", p.Name)
					} else {
						vv[tag] = fmt.Sprintf("${%s}:%s", p.Name, v)
					}
				}
			}
			if len(vv) > 0 {
				hcfg.Env[p.Name] = vv
			}
		}

		if p, ok := stmt.(*PathRemove); ok {
			//fmt.Printf("--- %q %v\n", p.Name, p.Value)
			continue

			vv := init_env_map_from(hcfg.Env, p.Name)
			for tag, v := range p.Value {
				v = sanitize_env_string(v)
				if _, haskey := vv[tag]; haskey {
					old := vv[tag]
					//fmt.Printf("--> %q\n", old)
					vv[tag] = fmt.Sprintf("%s:%s", old, v)

				} else {
					if v == "" {
						vv[tag] = fmt.Sprintf("${%s}", p.Name)
					} else {
						vv[tag] = fmt.Sprintf("${%s}:%s", p.Name, v)
					}
				}
			}
			if len(vv) > 0 {
				hcfg.Env[p.Name] = vv
			}
		}

		if p, ok := stmt.(*PathPrepend); ok {
			//fmt.Printf("--- %q %v\n", p.Name, p.Value)
			vv := init_env_map_from(hcfg.Env, p.Name)
			for tag, v := range p.Value {
				v = sanitize_env_string(v)
				if _, haskey := vv[tag]; haskey {
					old := vv[tag]
					//fmt.Printf("--> %q\n", old)
					if old == "" && v == "" {
						// no-op
					} else if old != "" && v == "" {
						vv[tag] = old
					} else if old == "" && v != "" {
						vv[tag] = v
					} else {
						vv[tag] = fmt.Sprintf("%s:%s", v, old)
					}
				} else {
					if v == "" {
						vv[tag] = fmt.Sprintf("${%s}", p.Name)
					} else {
						vv[tag] = fmt.Sprintf("%s:${%s}", v, p.Name)
					}
				}
			}
			if len(vv) > 0 {
				hcfg.Env[p.Name] = vv
			}
		}

		if p, ok := stmt.(*SetEnv); ok {
			//fmt.Printf("--- %q %v\n", p.Name, p.Value)
			vv := init_env_map_from(hcfg.Env, p.Name)
			for tag, v := range p.Value {
				v = sanitize_env_string(v)
				vv[tag] = v
			}
			if len(vv) > 0 {
				hcfg.Env[p.Name] = vv
			}
		}

	}

	out, err := goyaml.Marshal(hscript)
	handle_err(err)

	_, err = w.Write(out)
	handle_err(err)

	_, err = fmt.Fprintf(
		w,
		"\n## EOF ##\n",
	)
	handle_err(err)

	return err
}

// EOF
